// Разбираем reduce - метод переборки массива

// Рассмотрим логику работы: 
// Для начала простой пример, в котором посчитаем сумму эл. массивов
// Запускаем цикл:
let a = [1, 2, 3, 4];
let sum = 0;
for (let i = 0; i < a.length; i++) {
  sum = sum + a[i];
}
console.log(sum)

/* reduce - метод, который прменяет функцию к массиву 
* причем прменяет следю образом: 
* функция callback имеет несколько параметров - предыдущее(вычисляемое значение)
* (prev - вычисляемое значение)
* item - параметр;
* index - необязательный параметр
* Чему равно вычисляемое значение(prev) до старта? 
* Запишем, что prev = нулевой элемент массива, если мы не укажем сами.
*Его можно указывать, через запятую чему равен prev
*/
// Пример
// let b = a.reduce(function (prev, item, index) {
//   return prev + item;
// });
// console.log(b);

// Эту запись можно еще упростить добавив стрелочную функцию и убрать return и 
// фигурные скобочки
// Получилась запись в одну строчку
let b = a.reduce((prev, item, index) => prev + item);
console.log(b);

// Еще пример 

let arr = [3, 1, 2, 5, 1, 22, 4];
let max = arr[0];
for (let i = 0; i < arr.length; i++){
  // Как мы находим максимальный элемент массива? 
  // Если текущий элемент перебора больше, чем максимальное, 
  // то максимальному присваиваем текущий элемент
  if (arr[i] > max) {
    max = arr[i];
  }
}
console.log(max);
// Теперь то же самое проделаем с методом Reduce

let c = arr.reduce((prev, item) => {
  // prev - вычисляемое значение
  // item - текущий круг перебора
  // Итак, что нужно сделать? 
  // prev у меня изначально должен равнаяться а[0], поэтому его можно не писать
  // Я пишу: Если prev меньше item, то 
  if (prev < item) {
    return item;
  } 
  else {
    return prev;
  }
}, a[0]);
console.log(c)
// Какая логика? 
// Поскольку я не указываю изначальное значение prev, то в него помешяется нулевой элемент массива
// Дальше сравниваю. В item попадает следующее значение 
// Если item больше, я в prev записываю item, если меньше, оставляю prev

// Попробуем задать нулевой элемент массива в конце после фигурной скобки

// Теперь можем усложнить задачу и попробуем узнать индекс максимального элемента
// Как я нахожу индекс? 
// Если бы я использовала классическое вычисление, то это выглядело бы так: 

max = arr[0];
// Добавляю переменную index
let index = 0;
for (let i = 0; i < arr.length; i++){
  if (arr[i] > max) {
    max = arr[i];
    index = i;
  }
}
console.log(index);
// Это классический подход с циклом 
// Что же делать внутри reduce? 

// В reduce у нас есть возможность хранить вычисляемое значение, 
// но второй переменной, как мы делали для индекса здесь нет
// Но есть хитрая штука: 

let d = arr.reduce((prev, item, index) => {
  // Что же задать в качестве начального значение 
  // И вот здесь и пригодится хитрость: никто не ограничивает меня в 
  // типе начального значения
  // Я могу задать массив, внутрь которого я помещу массив, 
  // внутрь которого я помещу нулевым значением индекс, 
  // а значением под индекосм 1 будет a[0];
  // Такая вот хитрость: теперь внутри prev у меня зусунут массив 
  // Сейчас там два значения, но так как это массив, я 
  // могу поместить туда неограниченное число элементов
  // Теперь внутри функции я делаю следующее: 
  // Если текущий элемент больше, чем prev[1], 
  // то я должна внутрь prev поместить index и item
  // В противном случае нужно возвратить то значение, которое было
  if (item > prev[1]) {
    return [index, item]
  }
  else {
    return prev;
  }
}, [0, a[0]]);
// В начальное значение я поместила нулевой индекс и нулевое значение 
// Вот здесь я сравниваю if (item > prev[1]) текущее значение массива с вот этим a[0]
// Если текущее больше, я обновляю и число item и index и внутри 
// prev у меня продолжает лежать массив

console.log(d)
// В консоли я вижу массив из двух элементов: 
// (2) [5, 22]
// Где 5 - индекс элемента, а 22 - сам элемент, т.е максимальное значение массива 